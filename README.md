# Example of microservice-based application running on Tanzu Application Service (Former Pivotal Cloud Foundry)
<br>
This demo aims to show the power of Tanzu Application Service (TAS) platfom when it comes to run microservices developed using [Spring Cloud](https://spring.io/projects/spring-cloud) projects: **Spring Cloud Netflix**, **Spring Cloud OpenFeign**, **Spring Cloud Config** and **Spring Cloud Gateway**.
<br>
<br>
<img src="scMSA.png"> 
<br>
Each service binds to Eureka Server to discover all the others and automatically start using *client-side load balancing* through OpenFeign. The front-end service will accordingly configure its home page when running on Tanzu Application Service (TAS).<br>
Different (application instances) AIs will render the UI using different background colors, up to 4 different colors.<br>
<br>
You can generate 10 readers at a time clicking on the button <i>Load Readers</i>.<br>
You can generate 100 books at a time clicking on the button <i>Load Books</i>. The first 40 books will evenly be assigned to some readers.<br>
You can visualise the list of readers and books following the corresponding links. Use the browser's back buttom to return to the home page.<br>
<p/>
<p/>
<h2>Testing locally:</h2>
<br>
<code>java -jar configserver/build/libs/configserver-1.0.0.jar</code><br>
<code>java -jar registry/build/libs/registry-1.0.0.jar</code><br>
<code>java -jar application/build/libs/application-1.0.0.jar</code><br>
<code>java -jar book/build/libs/book-1.0.0.jar</code><br>
<code>java -jar reader/build/libs/reader-1.0.0.jar</code><br>
<p/>
<ins>URL:</ins><br>
localhost:8080
<p/>
<p/>
<h2>Testing on the cloud:</h2>
<br>
1. Install all required services and push the applications on TAS running the <code>./scripts/init.sh</code>command.<br>
<br>
Look for the route created on the output generated by the previous command, e.g.<br>
<br>
2. Use the published route to access the application running on TAS. You will notice that the home page looks different now. The application has detected it is running on TAS :) <br>
<ins>URL:</ins><br>
<code>http://library-msa.cfapps.io</code><br>
<br>
3. Generate some data clicking on <i>Load Readers</i> and <i>Load Books</i> buttons.<br>
<br>
4. Scale out the front-end application via the <code>cf scale app library-msa -i 3</code>command.<br>
<br>
You will notice that all AIs show consistent lists of readers and books as the both **Reader** and **Book** services are using the database services bound to them.<br>
<br>
5. Stop the **Reader** service instance using the <code>cf stop library-reader-service</code> command.<br>
<br>
6. You can verify that the **Reader** service instance is gone clicking on the *List of Readers* link. The list shows up empty.<br>
<br>
7. Navigate to the *List of Books* page. Borrowing a book to some reader who hasn't yet borrowed any books should be successful despite the *Reader* service being down. This is the *circuit breaker* in action.<br>
<br>
8. You can access the back-end services RESTful APIs via the Spring Cloud Gateway. For example, retrieve the list of books using the <code>http library-gtw.cfapps.io/library-book-service/books</code> command.
<p/>
<p/>
<h2>Cleaning up:</h2>
<br>
9. <code>./scripts/cleanup.sh</code><br>
<p/>
<p/>
<h2>Architectural Decisions:</h2>
<br>
1) The application followes the microservice architecture pattern, with the back-end services serving RESTful APIs. The front-end service implements the Model-View-Controller (MVC) architectural pattern which is made easy by the Spring framework.<br> 
<br>
2) The front-end service can easily consume the RESTful APIs thanks to the declarative model offered by the Spring Cloud OpenFeign library<br>
<br>
3) This microservice architecture leverages a service registry, config server and API gateway, all implemented using the Spring Cloud project.<br>
<br>
4) SQL databases have been chosen as data stores. The default implementations of both **Reader** and **Book** services are the H2 embedded in-memory database when running locally.<br>

